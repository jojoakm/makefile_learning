# ex01 知识点讲解：最小 Makefile（连贯版）

本关目标：你先知道 `make` 是谁、它做什么，再看语法，再看它怎么判断要不要重编。

---

## 1) 先定义两个角色（先别急着看语法）

- `make`：构建工具（命令）。你在终端里执行它。
- `Makefile`：规则文件。你在文件里写“目标、依赖、命令”。

一句话：**你执行 `make`，它去读取 `Makefile`。**

---

## 2) 先跑一遍，建立直觉

在 `ex01_hello` 目录执行：

```bash
make
make run
```

你会看到：

1. `make` 先根据 `Makefile` 生成可执行文件 `hello`
2. `make run` 再运行 `./hello`

有了这个直觉，再看语法就不会“凭空出现 make”。

---

## 2.5) 你输入 `make` 后，电脑一步一步在做什么

假设你在 `ex01_hello` 目录输入：

```bash
make
```

`make` 会按这个顺序执行：

1. 找 `Makefile` 文件并读取规则  
2. 因为你没写目标名，默认使用第一个目标（这里通常是 `all`）  
3. 查看 `all` 的依赖（这里是 `$(TARGET)`，也就是 `hello`）  
4. 找到 `hello` 的规则：`hello: main.c`  
5. 比较时间戳（`hello` 和 `main.c`）判断是否需要重建  
6. 如果需要，就执行命令：`gcc main.c -o hello`  
7. 生成/更新 `hello` 后，`all` 目标完成，`make` 结束  

你可以把它理解成：**`make` 在做“依赖图检查 + 必要命令执行”**。

---

## 3) 现在再看最小语法

一条规则的标准格式：

```make
target: dependencies
	命令
```

例子：

```make
hello: main.c
	gcc main.c -o hello
```

这里的含义是：

- `target`（`hello`）：我想要的结果文件
- `dependencies`（`main.c`）：生成它所需输入
- `命令`：如果需要构建，就执行这条 shell 命令

---

## 4) `make` 到底怎么判断“要不要执行命令”

`make` 的核心判断是时间戳：

- 目标不存在 -> 构建
- 依赖比目标新 -> 重建
- 目标比依赖新 -> 不重建（up to date）

你可直接验证：

```bash
make
make
touch main.c
make
```

---

## 5) 本关变量是干什么的

示例：

```make
CC ?= gcc
CFLAGS ?= -O2 -Wall -Wextra
TARGET := hello
SRC := main.c
```

- `CC`：编译器
- `CFLAGS`：编译参数
- `TARGET`：输出文件名
- `SRC`：输入源码文件

变量化价值：少写硬编码、易维护、可命令行覆盖。

---

## 6) 变量赋值和覆盖（这一关只记最实用）

- `?=`：默认值，命令行可覆盖
- `:=`：立即赋值

命令行覆盖示例：

```bash
make CC=clang
make CFLAGS="-O0 -g -Wall -Wextra"
```

---

## 7) 自动变量（你会在所有章节反复见到）

- `$@`：当前目标
- `$<`：第一个依赖
- `$^`：所有依赖

单源文件常见写法：

```make
$(TARGET): $(SRC)
	$(CC) $(CFLAGS) $< -o $@
```

多源文件写法示例：

```make
app: main.c util.c
	gcc $^ -o $@
```

---

## 8) `.PHONY`（防“同名文件”坑）

```make
.PHONY: all run clean help
```

表示这些是动作目标，不是文件目标。  
否则目录里如果真有一个叫 `clean` 的文件，`make clean` 可能不执行。

---

## 9) 你现在该怎么做 TASK（顺序）

1. `make help`
2. `make`
3. `make run`
4. 覆盖一次参数：`make CFLAGS="-O0 -g -Wall -Wextra"`
5. 增加 `print-vars` 目标并运行

`print-vars` 示例：

```make
.PHONY: print-vars
print-vars:
	@echo "CC=$(CC)"
	@echo "CFLAGS=$(CFLAGS)"
	@echo "TARGET=$(TARGET)"
	@echo "SRC=$(SRC)"
```

---

## 10) 常见错误（按概率排序）

- `missing separator`：命令前不是 Tab
- `No rule to make target ...`：目标/依赖路径或名字写错
- 改了参数没变化：先 `make clean && make`
- `hello` 打不开：它是二进制可执行文件，不是文本源码

---

## 11) 这一关过关线

满足这 4 条就过关：

1. 能解释 `target: deps` 的语义
2. 能解释 `make` 的时间戳判断
3. 能手写 `all/run/clean`
4. 会用命令行覆盖 `CFLAGS`
