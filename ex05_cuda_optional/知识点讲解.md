# ex05 知识点讲解：CUDA 场景下的 Makefile（连贯版，可选）

本关目标：把前四章的通用 Makefile 能力，迁移到 CUDA 编译和 NCU 分析流程。

---

## 1) 这一章在整套里的位置

- 前四章已经覆盖你日常项目 90% 需求。
- 这一章是“迁移章”：语法不变，工具换成 `nvcc`，参数换成 CUDA 相关。
- 所以它是可选加分，不是前置门槛。

---

## 2) 先跑一遍，先建立直觉

在 `ex05_cuda_optional` 下执行：

```bash
make clean
make
make run
```

你先确认：CUDA 项目的 Makefile 用法和前几章一样，只是编译器参数不同。

---

## 3) 最小 CUDA 构建规则怎么读

```make
NVCC ?= nvcc
TARGET := vec_add
SRC := vector_add.cu

$(TARGET): $(SRC)
	$(NVCC) $(NVCC_FLAGS) $< -o $@
```

对照前几章：

- `NVCC` 对应之前的 `CC/CXX`
- `SRC/TARGET` 逻辑不变
- 规则结构依旧是 `target: deps + command`

---

## 4) `CUDA_ARCH` 为什么必须参数化

不同机器架构号不同，写死会降低可移植性：

```make
CUDA_ARCH ?= 89
```

命令行覆盖：

```bash
make CUDA_ARCH=89
make CUDA_ARCH=120
```

如果报不支持架构，说明本机 nvcc 版本不支持该架构号。

---

## 5) `-gencode` 两行到底在干什么

```make
-gencode arch=compute_$(CUDA_ARCH),code=sm_$(CUDA_ARCH)
-gencode arch=compute_$(CUDA_ARCH),code=compute_$(CUDA_ARCH)
```

- `sm_xx`：本架构机器码，直接运行快
- `compute_xx`：保留 PTX，利于前向兼容

这就是你后续两个 CUDA 项目的推荐默认组合。

---

## 6) `NVCC_FLAGS` 里这几个参数最实用

```make
NVCC_FLAGS := -O3 -std=c++17 -lineinfo ...
```

- `-O3`：优化
- `-std=c++17`：语言标准
- `-lineinfo`：让 Nsight 报告能映射回源码行

---

## 7) 把 profile 固化为目标（关键习惯）

推荐：

```make
.PHONY: profile
profile: $(TARGET)
	mkdir -p reports
	ncu --set default -o reports/vec_add ./$(TARGET)
```

这样性能分析可复现，而不是依赖手工命令历史。

---

## 8) 运行参数与 Makefile 结合

若程序支持命令行参数，可写：

```make
run: $(TARGET)
	./$(TARGET) $(ARGS)
```

调用：

```bash
make run ARGS="1000000"
```

---

## 9) 常见错误和修复

- `nvcc: command not found`：CUDA 环境没装好或 PATH 未配置
- `unsupported gpu architecture`：架构号超出当前 nvcc 支持
- NCU 报权限/驱动问题：先确认程序能正常运行，再排 Nsight 环境

---

## 10) 本章过关标准

满足这 4 条就足够：

1. 能用 `CUDA_ARCH` 覆盖编译
2. 能解释 `-gencode` 两行的作用
3. 能跑通 `make / make run / make profile`
4. 能把这套写法迁移到你的两个 CUDA 项目里
