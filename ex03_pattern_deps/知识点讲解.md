# ex03 知识点讲解：模式规则 + 自动依赖（超详细版）

这一章是你从“会写 Makefile”走向“会写工程 Makefile”的关键一章。  
目标只有两个：

1. 规则不重复（用模式规则）
2. 头文件改动不漏编（用自动依赖 `.d`）

---

## 0) 先把这章放到全局里

你前一章（ex02）已经会：

- 把多个 `.cpp` 编译成 `.o`
- 再把 `.o` 链接成可执行文件
- 用变量管理编译器和参数

但是 ex02 仍有两个工程痛点：

- `.cpp` 文件一多，每个文件都要写一条编译规则，重复严重
- `.h` 变化时，容易漏掉应该重编的 `.o`

ex03 就是为了解决这两个问题。

---

## 1) 先建立一个正确心智：`make` 到底在干嘛

`make` 不是“从上到下执行脚本”。  
`make` 是在做三件事：

1. 找目标（target）
2. 递归处理依赖（dependencies）
3. 根据时间戳决定要不要执行命令（recipe）

你输入 `make` 后，默认构建第一个目标（本项目是 `all`）。  
`all` 依赖 `stats_app`，所以会继续去构建 `stats_app`。  
`stats_app` 又依赖一组 `.o`，于是继续递归去构建每个 `.o`。

---

## 2) 这份 Makefile 的“逐行翻译”

### 2.1 工具和参数

```make
CXX ?= g++
CXXFLAGS ?= -O2 -Wall -Wextra -std=c++17 -MMD -MP
INCLUDES := -Iinclude
```

- `CXX`：C++ 编译器，默认 `g++`，可命令行覆盖（如 `make CXX=clang++`）
- `CXXFLAGS`：编译参数
  - `-O2` 优化
  - `-Wall -Wextra` 更严格告警
  - `-std=c++17` C++17 标准
  - `-MMD -MP` 自动生成头文件依赖
- `INCLUDES`：头文件搜索路径（告诉编译器去 `include/` 找头文件）

---

### 2.2 目录和目标名

```make
SRC_DIR := src
BUILD_DIR := build
TARGET := stats_app
```

- `SRC_DIR`：源码目录
- `BUILD_DIR`：中间产物目录（`.o/.d`）
- `TARGET`：最终可执行文件名

---

### 2.3 三个核心集合变量（本章主角）

```make
SRCS := $(wildcard $(SRC_DIR)/*.cpp)
OBJS := $(patsubst $(SRC_DIR)/%.cpp,$(BUILD_DIR)/%.o,$(SRCS))
DEPS := $(OBJS:.o=.d)
```

#### `SRCS`
- 从 `src/` 自动收集所有 `.cpp`
- 例如得到：`src/main.cpp src/stats.cpp`

#### `OBJS`
- 把 `src/xxx.cpp` 映射成 `build/xxx.o`
- 例如：`build/main.o build/stats.o`

#### `DEPS`
- 把每个 `.o` 映射成 `.d`
- 例如：`build/main.d build/stats.d`

这三个变量构成一条链：

`源文件集合 -> 对象文件集合 -> 依赖描述文件集合`

---

### 2.4 伪目标与默认入口

```make
.PHONY: all run clean help

all: $(TARGET)
```

- `.PHONY` 表示这些目标不是“真实文件目标”，是“动作名”
- `all` 是默认入口（你只敲 `make` 时会走它）

---

### 2.5 链接规则（把多个 `.o` 合成可执行文件）

```make
$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) $^ -o $@
```

自动变量：

- `$@`：当前目标（这里是 `stats_app`）
- `$^`：所有依赖（这里是一组 `.o`）

展开后类似：

```bash
g++ -O2 -Wall -Wextra -std=c++17 -MMD -MP build/main.o build/stats.o -o stats_app
```

---

### 2.6 模式规则（本章最关键）

```make
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@
```

你可以把 `%` 理解为“同名占位符”：

- `build/main.o` 对应 `src/main.cpp`
- `build/stats.o` 对应 `src/stats.cpp`

自动变量：

- `$@`：当前目标 `.o`
- `$<`：第一个依赖 `.cpp`
- `$(dir $@)`：目标文件所在目录（比如 `build/`）

`-c` 表示“只编译，不链接”。

---

### 2.7 运行、清理、帮助

```make
run: $(TARGET)
	./$(TARGET)

clean:
	rm -rf $(BUILD_DIR) $(TARGET)

help:
	@echo "..."
```

- `run` 依赖 `$(TARGET)`，所以没编好会先编
- `clean` 删除构建产物
- `help` 打印说明

---

### 2.8 自动依赖接入点

```make
-include $(DEPS)
```

意思是：尝试加载所有 `.d` 文件。  
前面的 `-` 表示“没有也别报错”（首次构建时 `.d` 还不存在）。

---

## 3) 你输入 `make` 后，逐步发生什么（按时序）

下面按“第一次构建”的真实逻辑走一遍：

1. 读取 Makefile，先解析变量和规则
2. 默认目标是第一个规则目标 `all`
3. 发现 `all` 依赖 `stats_app`
4. 找到 `stats_app: $(OBJS)`，准备先处理 `$(OBJS)`
5. `$(OBJS)` 展开为 `build/main.o build/stats.o`
6. 对 `build/main.o`：
   - 找到模式规则 `build/%.o: src/%.cpp`
   - 依赖 `src/main.cpp` 存在
   - 执行编译命令生成 `build/main.o`，同时生成 `build/main.d`
7. 对 `build/stats.o` 同理，生成 `build/stats.o` 和 `build/stats.d`
8. 依赖都就绪后，执行链接命令生成 `stats_app`
9. `all` 本身无命令，构建结束

第二次再执行 `make`（你没改文件）：

- `make` 比较时间戳后发现目标都“最新”
- 输出 `Nothing to be done for 'all'.`（或等价信息）

---

## 4) 自动依赖 `.d` 到底是什么

`.d` 文件本质是“某个 `.o` 依赖了哪些头文件”的清单。  
例如（示意）：

```make
build/stats.o: src/stats.cpp include/stats.h
```

有了这个信息，`make` 在你 `touch include/stats.h` 后就知道：

- `build/stats.o` 过期，需要重编
- 以及其他依赖该头的 `.o` 也需要重编

这就是“改头文件后不会漏编”的根本原因。

---

## 5) 你必须做的 4 个实验（做完就真正掌握）

### 实验 1：完整构建

```bash
make clean
make
./stats_app
```

看程序是否正常输出均值和最大值。

### 实验 2：验证增量构建

```bash
make
```

不改任何文件再跑，应该几乎不做事。

### 实验 3：验证头文件触发重编

```bash
touch include/stats.h
make
```

应该看到相关 `.o` 被重编（不是全量盲目重编）。

### 实验 4：验证新增源码自动接入

- 新建 `src/min_value.cpp`（实现一个新函数）
- 再 `make`
- 观察是否自动出现对应 `build/min_value.o`

---

## 6) 常见误区（你之前问过的点，这里一次讲清）

### 误区 A：`make` 会按文件从上到下执行
不是。`make` 按“目标依赖图”执行。

### 误区 B：`wildcard` 会自动编译
不会。它只负责“收集文件名”。

### 误区 C：`patsubst` 会生成文件
不会。它只做“字符串映射”。

### 误区 D：有规则就一定执行命令
不是。还要先判断目标是否需要更新（时间戳逻辑）。

---

## 7) 故障排查速查表

- `No rule to make target ...`：依赖路径或模式规则写错
- 改 `.h` 没重编：检查是否有 `-MMD -MP` 和 `-include $(DEPS)`
- `missing separator`：命令行前用了空格不是 Tab
- 状态混乱：`make clean && make`

---

## 8) 本章过关标准（你按这个自测）

满足以下 5 条就算 ex03 通过：

1. 能解释 `%` 模式规则如何匹配 `src/xxx.cpp -> build/xxx.o`
2. 能解释 `SRCS -> OBJS -> DEPS` 三段映射链
3. 知道 `$@`、`$<`、`$^` 分别指什么
4. 说清楚 `-MMD -MP` + `-include $(DEPS)` 的配合机制
5. 实测通过“改 `.h` 触发正确重编”和“新增 `.cpp` 自动纳入构建”
