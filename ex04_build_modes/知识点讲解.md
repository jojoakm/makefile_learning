# ex04 知识点讲解：Debug/Release 构建模式（细化版）

本章目标：让同一份代码支持多种构建模式，并把测试动作纳入构建流程。

---

## 1) 这章在学什么（和前两章关系）

- ex02 解决“能构建多文件”
- ex03 解决“可扩展 + 自动依赖”
- ex04 解决“同一项目在不同场景用不同编译参数”

一句话：从“能构建”升级到“可调试、可发布、可验证”。

---

## 2) 先跑一遍，先看模式切换

在 `ex04_build_modes` 执行：

```bash
make clean
make BUILD=debug
make test
make BUILD=release
make run
```

你要观察：

- `BUILD=debug` 和 `BUILD=release` 走不同参数
- `test` 目标会自动验证输出

---

## 3) `BUILD` 分支逻辑怎么读

```make
BUILD ?= release

ifeq ($(BUILD),debug)
	CXXFLAGS := ... -O0 -g -DDEBUG
else ifeq ($(BUILD),release)
	CXXFLAGS := ... -O3 -DNDEBUG
else
$(error BUILD must be debug or release, got '$(BUILD)')
endif
```

要点：

- 默认是 `release`
- 可通过命令行覆盖：`make BUILD=debug`
- 非法值会直接报错，避免“静默错配”

---

## 4) debug 和 release 的工程语义

- `debug`
  - 低优化（便于调试）
  - 带调试信息（`-g`）
- `release`
  - 高优化（便于性能）
  - 通常禁用断言（`-DNDEBUG`）

实践规则：

- 查 bug -> debug
- 做性能数据 -> release

---

## 5) 为什么要分目录产物

```make
BUILD_DIR := build/$(BUILD)
```

效果：

- debug 编译产物在 `build/debug`
- release 编译产物在 `build/release`

好处：

1. 不互相覆盖
2. 切模式不需要每次全清理
3. 排查问题时可追踪不同模式结果

---

## 6) `debug/release` 目标不是魔法

示例：

```make
debug:
	$(MAKE) BUILD=debug
```

含义：只是给命令起别名，内部仍是递归调用 make + 传参。

---

## 7) `test` 目标为什么要放进 Makefile

示例：

```make
test: $(TARGET)
	@out="$$(./$(TARGET) hi 2)"; \
	if [ "$$out" = "hi hi" ]; then echo "test passed"; else exit 1; fi
```

价值：

- 每次构建后都能快速做功能回归
- 防止“能编译但结果错”的情况被带到下一阶段

---

## 8) 扩展任务：`sanitize` 模式怎么加

你可以在条件分支里增加：

```make
else ifeq ($(BUILD),sanitize)
	CXXFLAGS := $(CXXFLAGS_COMMON) -O1 -g -fsanitize=address,undefined
```

执行：

```bash
make BUILD=sanitize
make run
```

---

## 9) 高频问题（按你常问点整理）

### Q1：为什么我切了模式但感觉没变化？

- 检查是否真的传了 `BUILD=...`
- 检查 `CXXFLAGS` 是否在对应分支被覆盖
- 必要时 `make clean` 后重建

### Q2：为什么 `test` 要依赖 `$(TARGET)`？

- 确保测试前程序已构建且是当前模式产物

### Q3：`debug` 和 `release` 可以并存吗？

- 可以，前提是产物目录按 `build/$(BUILD)` 分离

---

## 10) 本章过关线

满足以下 4 条就通过：

1. 能解释 `BUILD` 分支逻辑
2. 能跑通 `debug -> test -> release -> run`
3. 能新增并跑通 `sanitize` 模式
4. 能说明“分目录构建”的必要性
